# 回溯算法

回溯算法的本质是一个决策树遍历过程，在层层递进的选择中遍历所有选择

代码方面，回溯算法的框架：

```
result = []
func backtrack(路径, 选择列表):
    # 1. 判断决策结果，将合法的结果添加到全局的缓存中
    if 满足结束条件: 
        result.add(路径)
        return

    # 2. 遍历所有选择
    for 选择 in 选择列表:
        2.1 做选择，更新选择路径
        做选择(更新路径)
        2.2 更新选择列表，进入下一层决策
        backtrack(路径, 选择列表') // 选择列表随着选择的作出调整，选择列表'~选择列表
        2.3 撤销选择, 恢复路径, 保证同层级的选择互相独立
        撤销选择
```

> PS1. 决策层级深入一层，并不意味着选择数的减少. 比如`跳台阶问题`（walk_step.go）
> PS2. 由于PS1的情况存在，如果所有的决策都不会导致选择减少，时间复杂度为o(n^m)(n=选择数,m=决策层数), 故应用中必须时刻关心性能问题

最后给出一个回溯算法的决策树模型图，让你可以更直观地感受这个算法:

```
ABC // 假设开始有ABC三个选择，以下格式为: 路径(选择列表)
|         \           \
|          \           \
A(BC)       B(AC)       C(AB)
|     \     |    \      |     \
AB(C) AC(B) BA(C) BC(A) CA(B) CB(A)
|     |     |     |     |     |
ABC() ACB() BAC() BCA() CAB() CBA()
```
