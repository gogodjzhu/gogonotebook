# 背包问题九讲笔记

## 01背包问题
01背包问题是所有背包问题的基础，典型特征为`每种物品只有1件，只能选择放或不放`。

### 01背包问题-案例1

典型题目有：*在背包容量已知为V的前提下，有N件物品(重量为Wi)，如何放入物品可令背包最满*。

> leetcode上面有[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/), 可以将其理解成背包容量为`half(Sum(arr))`的变种。利用它来验证你的算法。

demo:

```
func zeroOnePack01(V int, W []int) int {
	F := make([][]int, len(W) + 1)
	F[0] = make([]int, V + 1) // F[0, 0..V] <- 0
	for i := 1; i <= len(W); i++ { // i <- 1 to N
		Fi_1 := F[i-1]
		Fi := make([]int, V+1) // F[i,v]
		copy(Fi, Fi_1)
		for v := W[i-1]; v <= V; v++ { // v <- Wi to V
			leaveIt := Fi_1[v] // F[i-1, v]
			takeIt := Fi_1[v-W[i-1]] + W[i-1] // F[i-1, v-Wi] + Wi
			if takeIt > leaveIt {
				Fi[v] = takeIt // max{F[i-1, v], F[i-1, v-Wi] + Wi}
			} else {
				Fi[v] = leaveIt
			}
		}
		F[i] = Fi // F[i, V]
	}
	return F[len(W)][V]
}
```

状态转移方程为：

```
F[i,v]=max{F[i−1,v],F[i−1,v−Wi] + Wi} (i>=1)
```

方程中，

- `F[i,v]`指`前i件`物品放入容量为`v`的背包能装下的最大容量; 
- `F[i-1,v]`是`前i-1件`物品放入容量为`v`的背包能装下的最大容量(即选择不放`第i件`物品)
- `F[i-1,v-Wi]+Wi`是`前i-1`件物品放入容量为`v-Ci`(留出Ci的空间放第i件物品)的背包能装下的最大容量 + `第i件`物品的重量`Wi`(即选择放第i件物品)

对于`第i件`物品, 显然只有放入或不放入两种情况, 因此公式成立.

另外值得注意的是F中i的初始值为0, 表示`前0件`物品，即无任何物品放入时的情况。在本例中，`F[0]=[0..V]`, 即放入任意容量的背包，没有物品可选时最大容量都为0。

可以写出求解的伪代码:
```
F[0, 0...V] <- 0
for i <- 1 to N
    for v <- Wi to V
        F[i,v]=max{F[i−1,v],F[i−1,v−Wi] + Wi}
```

#### 01背包问题-空间复杂度优化

`F[0, 0...V]`可以从二维数组优化为一维, 变成`F[0...V]`保存`F[i,v]`在每次循环中的最新值。以下各种背包问题的延伸均可通过此方法进行空间优化, 不再赘述。


### 01背包问题-案例2
(algorithm/abstract/recursion/pack_problem.go#ZeroOnePack02)
可以将案例1扩展为，`N件物品(重量为Wi)有各自的价值P(Pi)，求如何放入物品可令背包价值最高`。

此时案例1中的状态转移方程需要稍作调整:
```
F[i,v]=max{F[i−1,v],F[i−1,v−Wi]+Pi} {i>=1}
```
方程中，F的涵义从容量变成价值, 放入`第i件`物品产生的增量变成`Pi`即其价值。

> 特别地, 可以将案例1的问题理解成案例2的一个特例，即物品的价值P与其重量W相等

## 完全背包问题
完全背包问题跟01背包问题的区别在于每件物品可以选择的次数是无限的.

### 完全背包问题-案例01
典型的完全背包问题有: *已知背包容量为V的前提下, 有N种物品(价值为P), 数量无限, 求背包能放下的最大价值*

状态转移方程为:
```
F[i,v]=max{F[i-1,v], F[i,v-Wi]+Pi} (i>=1)
```
`F[i,v]`的涵义与前述**01背包问题-案例2**的不同，表示的是在`第i件`物品纳入选择的情况下，在背包容量为v时能放下的最大价值。

此方程与**01背包问题-案例2**的状态转移方程变化是:`F[i−1,v−Wi]+Pi`->`F[i,v-Wi]+Pi`, 出现这种变化的原因在于01背包问题选择一种物品之后就不能再次选择, 而完全背包问题无此约束。

> 完全背包问题不能简单使用贪心算法求解。

### 完全背包问题-案例02
常见的一种问题变种为，在案例01其余条件不变的情况下，要求必须填满背包。
完整表述为：**已知背包容量为V的前提下, 有N种物品(价值为P), 数量无限, 完全填满背包时最多能放下多少价值(如果无法填满返回特殊值-1)**

定义状态`F[i,v]`发生变化, 代表的意思为：在`前i件`物品可选时，往容量为v的背包中填满最多能放下多少价值。 

状态转移方程不变，还是
```
F[i,v]=max{F[i-1,v], F[i,v-Wi]+Pi | F[i,v-Wi]!=-1} (i>=1)
```
但根据定义状态，初始值应做调整，V为0时最多能放下的值永远是0, 而任何大于0的容器需要填满都是不可能的用`前0件`物品填满的，故都为-1。因此`F[0]=[0,-1..V]`。

另外在计算`F[i,v-Wi]+Pi`的时候，需要进一步判断不为`-1`。

### 完全背包问题-案例03
此种题目从计算价值，变为计算填满背包的方案数量。
完整表述为：**已知背包最大容量max, 有一批物品重weights, 价值values, 每件物品数量无限, 求放满背包有多少种方案**

定义状态`F[i,v]`表示：在`前i件`物品可选时，填满容量为v的背包有几种方案。

状态转移方程变为:

```
F[i,v]=F[i-1,v]+F[i,v-Wi]
```
	对方程可以给出这样的解释: 不使用`第i个`物品装满v背包的方案数 + 使用`第i个`物品的前提下装满